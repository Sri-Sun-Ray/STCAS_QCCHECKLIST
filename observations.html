<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Observations</title>
  <script src="libs/jquery-3.6.0.min.js"></script>
  <script src="libs/zxing-browser.min.js"></script>
  <script src="libs/jspdf.umd.min.js"></script>
  <script src="libs/jspdf.plugin.autotable.min.js"></script>
  <script>
    function formatDescription(description) {
      if (!description) return "";
      // Convert &lt;b&gt; into <b> etc.
      const txt = document.createElement("textarea");
      txt.innerHTML = description;
      return txt.value;
    }
    function decodeHtmlEntities(str) {
      if (!str) return "";
      const txt = document.createElement("textarea");
      txt.innerHTML = str;
      return txt.value;
    }

    const specificOptions = {
      "1.38,1.40,1.41,1.42,1.43,1.44": ["Matching", "Not Matching", "Not Installed", "Not Applicable"],
      "1.39,1.2,1.3,1.4,1.5,1.6,1.7,1.8,1.9,1.10,1.11,1.12,1.13,1.14,1.15,1.16,1.17,1.18,1.19,1.20,1.21,1.22,1.23,1.24,1.25,1.26,1.27,1.28,1.29,1.30,1.31,1.32,1.33,1.34,1.35,1.36,1.37,1.1": ["Matching", "Not Matching", "Not Installed", "Not Applicable"],
      "3.1,3.3,3.4,3.4.1,3.4.2,3.5,3.6,3.2,2.1,2.2,2.3,2.3.1,2.4,2.5,2.6,2.7": ["Yes", "No", "Not Applicable"],
      "4.1,4.1.1,4.1.2,4.1.3,4.1.4,4.1.5,4.2,4.2.1,4.2.2,4.2.3,4.2.4,4.2.5,4.2.6,4.2.7,4.2.8,4.2.9,4.3,4.3.1,4.3.2,4.3.3,4.3.4,4.3.5,5.1,5.1.1,5.1.2,5.1.3,5.1.4,5.1.5,5.1.6,5.1.7,5.1.8,5.1.9,5.1.10,5.1.11,5.1.12,5.2,5.2.1,5.2.2,5.2.3,5.2.4,5.2.5,5.2.6,5.2.7,5.2.5,5.3,5.3.1,5.3.2,5.3.3,5.3.4,5.3.5,5.3.6,5.3.7,5.3.8,5.4,5.4.1,5.4.2,5.4.3,5.4.4,5.4.5,6.1.1,6.1.2,6.1.3,6.1.4,6.1.5,6.1.6,6.1.7,6.1.8,6.1.9,6.1.10,6.1.11,6.1.12,6.1.13,6.2,6.2.1,7.1,7.1.1,7.1.2,7.2,7.2.1,7.3,7.3.1,7.3.2,7.4,7.4.1,7.4.2,7.5,8.1,8.1.1,8.1.2,8.2,8.2.1,8.2.2,8.2.3,8.2.4,8.2.5,8.2.6,8.2.7,8.3,8.4,9.1,9.2,9.3,9.4,9.5,10.1,10.2,10.3,10.4,10.5,10.6,10.7,10.8,11.1,11.2,11.3,12.1,12.2,12.3,13.1": ["Yes", "No"],
    };

  </script>
  <style>
    .status-green {
      background-color: green;
      color: white;
    }

    .status-red {
      background-color: red;
      color: white;
    }

    .status-blue {
      background-color: blue;
      color: white;
    }

    .status-yellow {
      background-color: yellow;
      color: black;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin-bottom: 20px;
    }

    th,
    td {
      border: 1px solid black;
      padding: 10px;
      text-align: left;
    }

    th:first-child,
    td:first-child {
      text-align: center;
    }

    /* Center S.No column */
    img {
      max-width: 50px;
      cursor: pointer;
    }

    .green {
      color: green;
      font-weight: bold;
    }

    .red {
      color: red;
      font-weight: bold;
    }

    .btn-container {
      margin: 20px 0;
      text-align: center;
    }

    .btn-container button {
      padding: 10px 20px;
      font-size: 16px;
      cursor: pointer;
    }

    .loco-details table {
      width: 100%;
      border-collapse: collapse;
      margin-bottom: 20px;
    }

    .loco-details td {
      padding: 15px;
      border: 1px solid black;
      text-align: left;
      width: 10%;
    }

    .loco-details strong {
      font-weight: bold;
    }

    .eye-icon {
      margin-left: 10px;
      cursor: pointer;
      color: #007bff;
      font-size: 18px;
    }

    .btn-container {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin: 20px;
    }

    #back-btn {
      background-color: #f44336;
      color: white;
      border: none;
      padding: 10px 20px;
      cursor: pointer;
      font-size: 16px;
      transition: background-color 0.3s ease;
    }

    #back-btn:hover {
      background-color: #d32f2f;
    }

    #convert-pdf-btn {
      background-color: #4CAF50;
      color: white;
      border: none;
      padding: 10px 20px;
      cursor: pointer;
      font-size: 16px;
      transition: background-color 0.3s ease, opacity 0.3s ease;
    }

    #convert-pdf-btn:disabled {
      background-color: #a5d6a7;
      opacity: 0.6;
      cursor: not-allowed;
    }

    #convert-pdf-btn:hover:not(:disabled) {
      background-color: #388e3c;
    }

    #go-to-report-btn {
      background-color: #2196F3;
      color: white;
      padding: 10px 20px;
      text-decoration: none;
      border-radius: 5px;
      font-size: 16px;
      transition: background-color 0.3s ease;
    }

    #go-to-report-btn:hover {
      background-color: #1976D2;
    }

    #observations-container {
      margin-bottom: 20px;
    }
  </style>
</head>

<body>
  <h1>Observations</h1>
  <div class="loco-details">
    <h2>Station Details</h2>
    <table>
      <tr>
        <td><strong>Station ID:</strong> <span id="station-id"></span></td>
        <td><strong>Station Name:</strong> <span id="station-name"></span></td>
        <td><strong>Zone:</strong> <span id="zone"></span></td>
        <td><strong>Division:</strong> <span id="division"></span></td>
        <td><strong>Section Name:</strong><span id="section-name"></span></td>
        <td><strong>Initial Date:</strong> <span id="initial-date"></span></td>
        <td><strong>Updated Date:</strong> <span id="updated-date"></span></td>
      </tr>
    </table>
  </div>
  <div id="observations-container"></div>
  <div class="btn-container">
    <button id="back-btn">Back</button>
    <button id="convert-pdf-btn" onclick="createNewReport()">Convert to PDF</button>
    <div id="success-message" style="display: none; color: green; margin-top: 10px;">
      PDF successfully created! Click <strong>Go to Report</strong> to view.
    </div>
    <a href="viewReports.php" id="go-to-report-btn" class="btn-link" style="display: none;">Go to Report</a>
  </div>
  <script>
    document.getElementById("back-btn").addEventListener("click", function (e) {
      e.preventDefault();
      // Navigate directly to create.html instead of using browser history
      window.location.href = "create.html#0.0";
    });
  </script>

  </script>
  <script>
    const stationDetails = JSON.parse(sessionStorage.getItem('stationInfo'));
    if (stationDetails) {
      const currentDate = new Date();
      const formattedCurrentDate = `${currentDate.getDate().toString().padStart(2, '0')}-${(currentDate.getMonth() + 1).toString().padStart(2, '0')}-${currentDate.getFullYear()}`;
      document.getElementById("station-id").textContent = stationDetails.stationId || 'N/A';
      document.getElementById("station-name").textContent = stationDetails.stationName || 'N/A';
      document.getElementById("zone").textContent = stationDetails.zone || 'N/A';
      document.getElementById("division").textContent = stationDetails.division || 'N/A';
      document.getElementById("section-name").textContent = stationDetails.sectionName || 'N/A';
      document.getElementById("initial-date").textContent = stationDetails.initialDate || 'N/A';
      document.getElementById("updated-date").textContent = stationDetails.updatedDate || 'N/A';
    } else {
      console.error('Station details not found in sessionStorage');
    }

    async function fetchObservations() {
      let stationId = stationDetails?.stationId;
      if (!stationId) {
        console.error("Station ID is missing.");
        return { status: 'error', message: 'Station ID is missing' };
      }
      try {
        const response = await fetch(`fetch_observations.php?station_id=${stationId}`);
        const text = await response.text();
        console.log("Raw backend response:", text);
        let data;
        try {
          data = JSON.parse(text);
        } catch (parseError) {
          console.error("JSON parsing error:", parseError, "Raw text:", text);
          return { status: 'error', message: 'Invalid JSON format from backend' };
        }
        if (data.status === 'success' && Array.isArray(data.data)) {
          window.totalCustomPoints = data.total_custom_points || 0;
          // Keep all data for calculation, but filter for detailed view later if needed
        }
        return data;
      } catch (error) {
        console.error("Fetch error:", error);
        return { status: 'error', message: error.message || 'Network error occurred' };
      }
    }

    function createObservationsTable(observations) {
      const sectionMetadata = {
        "1": { name: "Serial Number verification", base: 44 },
        "2": { name: "Building", base: 8 },
        "3": { name: "Tower", base: 8 },
        "4": { name: "Power Supply", base: 22 },
        "5": { name: "Kavach  Equipment", base: 36 },
        "6": { name: "RF Communication equipment on tower", base: 16 },
        "7": { name: "OFC Networking rack", base: 12 },
        "8": { name: "Relay rack", base: 13 },
        "9": { name: "Earthing", base: 5 },
        "10": { name: "Indoor wiring / cabling", base: 8 },
        "11": { name: "Outdoor cabling", base: 3 },
        "12": { name: "RFID Tags", base: 3 },
        "13": { name: "Components Inspection", base: 1 },
      };

      const subSectionMetadata = {
        "4.1": "4.1 IPS(Integrated Power System)",
        "4.2": "4.2 PDU(Power Distribution Unit)",
        "4.3": "4.3 DC-DC Converter",
        "5.1": "5.1 Kavach Unit",
        "5.2": "5.2 SMOCIP(Station Master's Operation-Cum-Indication Panel)",
        "5.3": "5.3 GPS/GSM Antennas",
        "5.4": "5.4 RIU(Remote Interface Unit)",
        "6.1": "6.1 RTU(Radio Tower Unit)",
        "6.2": "6.2 RF Antenna Installation"
      };

      const detailedObservationsDiv = document.createElement("div");
      detailedObservationsDiv.id = "detailed-observations-container";

      const grouped = {};
      observations.forEach(obs => {
        const section = obs.S_no && typeof obs.S_no === 'string' && obs.S_no.includes('.') ? obs.S_no.split('.')[0] : null;
        if (!section) {
          console.warn(`Invalid S_no: ${obs.S_no}`);
          return;
        }
        if (!grouped[section]) grouped[section] = [];
        grouped[section].push(obs);
      });

      let totalClosedPointsOverall = 0;
      let totalPointsOverallTracker = 0;

      const sectionStats = {};
      Object.keys(sectionMetadata).forEach(id => {
        const base = sectionMetadata[id].base;
        const sectionRows = grouped[id] || [];

        // Count custom rows
        let customCount = 0;
        sectionRows.forEach(obs => {
          const snoParts = obs.S_no.split('.');
          const lastPart = parseInt(snoParts[snoParts.length - 1]);
          if (id === "1" && lastPart > 44) customCount++;
          if (id === "2" && lastPart > 7) customCount++;
        });

        const sectionTotal = base + customCount;

        let closed = 0;
        sectionRows.forEach(obs => {
          const status = obs.observation_status ? obs.observation_status.trim() : "";
          const isClosed = ["Available", "Present", "Ok", "Yes", "Routing Done", "Fixed", "Secured", "Installed", "Connected", "Aligned", "Torquing done", "Positioning done", "Configured", "Welding done", "Earthing done", "Matching", "Not Applicable", "Coating done", "Applied", "Cables Connected", "Metal clamps implemented", "Locked", "Verified and ok"].includes(status);
          if (isClosed) closed++;
        });

        sectionStats[id] = {
          name: sectionMetadata[id].name,
          total: sectionTotal,
          closed: closed
        };

        totalClosedPointsOverall += closed;
        totalPointsOverallTracker += sectionTotal;
      });

      const totalPointsOverall = totalPointsOverallTracker;
      const totalClosedPoints = totalClosedPointsOverall;

      // Create detailed rows per section
      Object.keys(grouped).sort((a, b) => Number(a) - Number(b)).forEach(section => {
        const sectionRows = grouped[section];
        const sectionTable = document.createElement("table");
        sectionTable.className = "observations-table";
        sectionTable.style.marginBottom = "20px";

        const hasRequirement = section !== "1";

        let headerHTML = `
          <thead>
            <tr>
              <th style="text-align: center;">S_no</th>
              <th>Aspect</th>
              ${hasRequirement ? "<th>Requirement</th>" : ""}
              <th>Status</th>
              <th>Observation</th>
              <th>Image</th>
            </tr>
          </thead>
          <tbody></tbody>
        `;
        sectionTable.innerHTML = headerHTML;
        const tbody = sectionTable.querySelector("tbody");

        if (section !== "1" && section !== "2") {
          let startTime = '', completedTime = '', totalTime = '';
          let startDateObj = null, completedDateObj = null;
          if (sectionRows.length > 0) {
            const parseDate = s => {
              if (!s || typeof s !== 'string') return null;
              const date = new Date(s.replace(' ', 'T'));
              return isNaN(date.getTime()) ? null : date;
            };
            const createdTimes = sectionRows.map(obs => parseDate(obs.created_at)).filter(Boolean);
            const updatedTimes = sectionRows.map(obs => parseDate(obs.updated_at)).filter(Boolean);
            if (createdTimes.length > 0) {
              startDateObj = new Date(Math.min(...createdTimes));
              startTime = startDateObj.toLocaleString();
            }
            if (updatedTimes.length > 0) {
              completedDateObj = new Date(Math.max(...updatedTimes));
              completedTime = completedDateObj.toLocaleString();
            } else if (createdTimes.length > 0) {
              completedDateObj = new Date(Math.max(...createdTimes));
              completedTime = completedDateObj.toLocaleString();
            }
            if (startDateObj && completedDateObj) {
              const ms = completedDateObj - startDateObj;
              const totalSeconds = Math.floor(ms / 1000);
              const hours = Math.floor(totalSeconds / 3600);
              const minutes = Math.floor((totalSeconds % 3600) / 60);
              const seconds = totalSeconds % 60;
              totalTime = `${hours}h ${minutes}m ${seconds}sec`;
            }
          }
          const summaryTr = document.createElement("tr");
          summaryTr.style.background = "#f0f8ff";
          summaryTr.innerHTML = `
            <td colspan="${hasRequirement ? 6 : 5}" style="font-weight:bold;">
              Section ${section} ‚Äî ${sectionMetadata[section] ? sectionMetadata[section].name : ''}
            </td>
          `;
          tbody.appendChild(summaryTr);
        } else {
          // Add a simple section header for Section 1 and 2 too if needed
          const summaryTr = document.createElement("tr");
          summaryTr.style.background = "#f0f8ff";
          summaryTr.innerHTML = `
            <td colspan="${hasRequirement ? 6 : 5}" style="font-weight:bold;">
              Section ${section} ‚Äî ${sectionMetadata[section] ? sectionMetadata[section].name : ''}
            </td>
          `;
          tbody.appendChild(summaryTr);
        }



        let lastSubsection = "";
        sectionRows.sort((a, b) => {
          // Basic sort by S_no string, assuming standard format
          const aParts = a.S_no.split('.').map(Number);
          const bParts = b.S_no.split('.').map(Number);
          for (let i = 0; i < Math.max(aParts.length, bParts.length); i++) {
            const av = aParts[i] || 0;
            const bv = bParts[i] || 0;
            if (av !== bv) return av - bv;
          }
          return 0;
        });
        sectionRows.forEach(obs => {
          // Only show observations with a selected status (not "Select")
          if (!obs.observation_status || obs.observation_status.trim() === '' || obs.observation_status.trim() === 'Select') {
            return;
          }

          // Check for subsection change
          const parts = obs.S_no.split('.');
          if (parts.length >= 2) {
            const currentSubsection = parts[0] + "." + parts[1];
            if (currentSubsection !== lastSubsection && subSectionMetadata[currentSubsection]) {
              const subTr = document.createElement("tr");
              subTr.style.background = "#e6f2ff";
              subTr.innerHTML = `
                   <td colspan="${hasRequirement ? 6 : 5}" style="font-weight:bold; color: #0056b3; padding-left: 20px;">
                      ${subSectionMetadata[currentSubsection]}
                   </td>
                `;
              tbody.appendChild(subTr);
              lastSubsection = currentSubsection;
            }
          }

          const formattedDescription = formatDescription(obs.observation_text);
          let displayDescription = formattedDescription;
          if (obs.barcode_kavach_main_unit && obs.barcode_kavach_main_unit.trim() !== '') {
            const cleanBarcode = obs.barcode_kavach_main_unit.trim();
            // Remove existing barcode occurrences
            displayDescription = displayDescription.split(cleanBarcode).join('').trim();
            // Clean up trailing hyphens
            while (displayDescription.endsWith('-')) {
              displayDescription = displayDescription.slice(0, -1).trim();
            }
            displayDescription += ` - ${cleanBarcode}`;
          }

          let statusText = (obs.observation_status || '').trim();
          let statusColor = '';
          const isGreen = ["Available", "Present", "Ok", "Yes", "Routing Done", "Fixed", "Secured", "Installed", "Connected", "Aligned", "Torquing done", "Positioning done", "Configured", "Welding done", "Earthing done", "Matching", "Not Applicable", "Coating done", "Applied", "Cables Connected", "Metal clamps implemented", "Locked", "Verified and ok"].includes(statusText);

          if (isGreen) {
            statusColor = 'green';
          } else if (["Not Present", "No", "Not Matching", "Not Installed", "Found Not Ok", "Not Implemented", "Not Fixed", "Not Connected", "Routing Not done", "Voltage found not Ok", "Torquing Not done", "Not Done", "Not Ok", "PCCL Not Done", "Earthing Not done", "Not Functioning", "Identification Not Done", "Cable ties not implemented", "Not Joined", "Quantity Not Matched"].includes(statusText)) {
            statusColor = 'red';
          } else {
            statusColor = 'yellow';
          }

          const tr = document.createElement("tr");
          let imageHTML = 'No Image';
          if (obs.image_paths && Array.isArray(obs.image_paths) && obs.image_paths.length > 0) {
            imageHTML = obs.image_paths.map(path =>
              `<img src="${path}" onclick="window.open('${path}', '_blank')" style="max-width: 100px; cursor: pointer; margin-right:5px;" />`
            ).join('');
          }
          tr.innerHTML = `
            <td style="text-align: center;">${obs.S_no}</td>
            <td>${displayDescription}</td>
            ${hasRequirement ? `<td>${obs.requirement_text || "N/A"}</td>` : ""}
            <td style="color: ${statusColor}; font-weight: bold;">${statusText}</td>
            <td>${obs.remarks}</td>
            <td>${imageHTML}</td>`;
          tbody.appendChild(tr);
        });

        if (section === "1") {
          const noteTr = document.createElement("tr");
          noteTr.innerHTML = `<td colspan="5" style="background:#fff8dc; font-size: 0.9em; padding: 10px;">
             ‚ö†Ô∏è <strong>Note:</strong> If any card or unit is replaced, kindly enter the new number and mention FSR details along with the old card number in the <strong>Remarks</strong> section.
           </td>`;
          tbody.appendChild(noteTr);
        }

        detailedObservationsDiv.appendChild(sectionTable);
      });

      const observationsContainer = document.getElementById("observations-container");
      observationsContainer.innerHTML = "";

      observationsContainer.appendChild(document.createElement("h2")).innerHTML = `<i class="fas fa-list-check"></i> Detailed Observations`;
      observationsContainer.appendChild(detailedObservationsDiv);


      return detailedObservationsDiv;
    }

    function groupObservationsBySection(observations) {
      if (!Array.isArray(observations)) {
        console.error('Expected an array of observations, but got:', observations);
        return {};
      }
      const grouped = {};
      observations.forEach(observation => {
        const section = observation.S_no && typeof observation.S_no === 'string' && observation.S_no.includes('.') ? observation.S_no.split('.')[0] : null;
        if (!section) {
          console.warn(`Invalid S_no: ${observation.S_no}`);
          return;
        }
        if (!grouped[section]) {
          grouped[section] = [];
        }
        grouped[section].push(observation);
      });
      console.log('Grouped Obs:', grouped);
      return grouped;
    }

    async function renderObservations() {
      const observationsData = await fetchObservations();
      if (observationsData.status === 'success' && Array.isArray(observationsData.data)) {
        // Sort observations by S_no before passing to createObservationsTable
        const sortedObservations = observationsData.data.sort((a, b) => {
          const aParts = a.S_no.split('.').map(Number);
          const bParts = b.S_no.split('.').map(Number);
          for (let i = 0; i < Math.max(aParts.length, bParts.length); i++) {
            const av = aParts[i] || 0;
            const bv = bParts[i] || 0;
            if (av !== bv) return av - bv;
          }
          return 0;
        });
        createObservationsTable(sortedObservations);
      } else {
        const container = document.getElementById('observations-container');
        container.innerHTML = `<p>${observationsData.message || 'No observations available for this station.'}</p>`;
      }
    }

    function formatDateString(dateString) {
      if (!dateString || typeof dateString !== 'string') return 'N/A';
      const dateParts = dateString.split('-');
      if (dateParts.length !== 3) return 'N/A';
      return `${dateParts[0]}-${dateParts[1]}-${dateParts[2]}`;
    }

    async function createNewReport() {
      const pdfButton = document.getElementById("convert-pdf-btn");
      pdfButton.disabled = true;
      pdfButton.textContent = "Generating...";
      pdfButton.style.opacity = "0.6";
      try {
        console.log("üöÄ Starting createNewReport function...");
        const stationId = document.getElementById("station-id")?.textContent.trim() || "N/A";
        if (!stationId || stationId === "N/A") {
          alert("‚ö†Ô∏è station ID not found. Cannot update completed time.");
          return;
        }
        try {
          const response = await fetch('update_completed_time.php', {
            method: 'POST',
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            body: `station_id=${encodeURIComponent(stationId)}`
          });
          const result = await response.json();
          console.log("üïí Completed time update response:", result.message);
        } catch (error) {
          console.error("‚ùå Failed to update completed time:", error);
        }
        const timingsRes = await fetch(`get_loco_timings.php?station_id=${encodeURIComponent(stationId)}`);
        const timingsData = await timingsRes.json();
        let startTime = "";
        let completedTime = "";
        let totalTime = "";
        if (timingsData.success) {
          startTime = timingsData.start_time;
          completedTime = timingsData.completed_time;
          const start = new Date(startTime);
          const end = new Date(completedTime);
          if (!isNaN(start.getTime()) && !isNaN(end.getTime())) {
            const ms = end - start;
            const totalSeconds = Math.floor(ms / 1000);
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            totalTime = `${hours}h ${minutes}m ${seconds}sec`;
          } else {
            console.warn("Invalid start or end time for total time calculation");
          }
        } else {
          console.warn("‚ö†Ô∏è Could not fetch timings:", timingsData.message);
        }
        const observationsData = await fetchObservations();
        console.log('üì¶ Creating PDF with observations:', observationsData);
        const updatedDate = document.getElementById("updated-date")?.textContent || "N/A";
        const formattedInspectionDate = formatDateString(updatedDate);
        const employeeName = localStorage.getItem("employee_name") || "N/A";
        console.log("Retrieved Employee Name:", employeeName);
        const jsPDF = window.jspdf ? window.jspdf.jsPDF : window.jsPDF;
        if (!jsPDF) {
          alert("jsPDF library not loaded. Please check your internet connection.");
          pdfButton.disabled = false;
          pdfButton.textContent = "Convert to PDF";
          return;
        }
        const pdf = new jsPDF();
        const observationsArray = observationsData.data;
        console.log("üìã Observations Array Loaded: ", observationsArray);

        // Filter for PDF display (body) - only show filled rows
        const pdfObservations = observationsArray.filter(obs =>
          obs.observation_status && obs.observation_status.trim() !== '' && obs.observation_status.trim() !== 'Select'
        );
        // const pdfObservations = observationsArray;
        // const pdfObservations = observationsArray.filter(obs =>
        //   obs.observation_status && obs.observation_status.trim() !== '' && obs.observation_status.trim() !== 'Select'
        // );
        console.log("üìã PDF Observations (Table Content): ", pdfObservations);

        // Load images only for displayed rows
        const imagePromises = pdfObservations.map(async (obs) => {
          const imageList = [];
          if (obs.image_paths && Array.isArray(obs.image_paths) && obs.image_paths.length > 0) {
            for (const path of obs.image_paths) {
              console.log(`üåÑ Loading image: ${path}`);
              const base64 = await getBase64Image(path);
              if (base64) {
                console.log(`‚úÖ Successfully converted image to base64: ${path}`);
                imageList.push(base64);
              } else {
                console.warn(`‚ö†Ô∏è Failed to convert image to base64: ${path}`);
              }
            }
          }
          return { S_no: obs.S_no, images: imageList };
        });
        console.log("üì§ Initiating Image Loading...");
        const imageDataArray = await Promise.all(imagePromises);
        console.log("‚úÖ Images Loaded Successfully:", imageDataArray);
        const imageData = {};
        imageDataArray.forEach(entry => {
          imageData[entry.S_no] = entry.images;
        });
        console.log("üìÅ Processed Image Data:", imageData);

        const logoPath = 'hbl_logo.jpg';
        const logoBase64 = await getBase64Image(logoPath);
        const pageHeight = pdf.internal.pageSize.height;
        const footerHeight = 15;
        const bottomMargin = 20;
        let finalY = 10;

        if (logoBase64) {
          const logoWidth = 30;
          const logoHeight = 20;
          const pageWidth = pdf.internal.pageSize.width;
          const xPosition = pageWidth - logoWidth - 10;
          pdf.addImage(logoBase64, 'JPEG', xPosition, finalY, logoWidth, logoHeight);
        }
        pdf.setFont("helvetica", "bold");
        pdf.setFontSize(14);
        pdf.text("HBL Engineering Limited", pdf.internal.pageSize.width / 2, finalY + 5, { align: "center" });
        pdf.setFont("helvetica", "normal");
        pdf.setFontSize(12);
        pdf.text("Rail Signaling Group", pdf.internal.pageSize.width / 2, finalY + 12, { align: "center" });
        pdf.setFont("helvetica", "bold");
        pdf.text("In-Process QC Checklist for Stationary Kavach Installation", pdf.internal.pageSize.width / 2, finalY + 20, { align: "center" });
        pdf.setFont("helvetica", "normal");
        pdf.text(`QC Engineer Name: ${employeeName}`, 10, finalY + 26);
        pdf.text("v1.0", pdf.internal.pageSize.width - 10, finalY + 26, { align: "right" });
        pdf.line(10, finalY + 28, pdf.internal.pageSize.width - 10, finalY + 28);
        finalY += 30;

        const stationDetailsRow = [
          document.getElementById("station-id")?.textContent || "N/A",
          document.getElementById("station-name")?.textContent || "N/A",
          document.getElementById("zone")?.textContent || "N/A",
          document.getElementById("division")?.textContent || "N/A",
          document.getElementById("section-name")?.textContent || "N/A",
          document.getElementById("initial-date")?.textContent || "N/A",
          document.getElementById("updated-date")?.textContent || "N/A"
        ];
        pdf.autoTable({
          head: [["Station ID", "Station Name", "Zone", "Division", "Section Name", "Initial Date", "Updated Date"]],
          body: [stationDetailsRow],
          startY: finalY,
          margin: { right: 10 },
          theme: "grid",
          styles: {
            fontSize: 9,
            cellPadding: 1,
            overflow: 'linebreak',
            lineWidth: 0.1,
            lineColor: [0, 0, 0],
            halign: 'center',
            valign: 'middle'
          },
          headStyles: {
            textColor: [255, 255, 255],
            fillColor: [0, 102, 204],
            lineWidth: 0.5,
            lineColor: [0, 0, 0]
          },
          bodyStyles: {
            lineWidth: 0.5,
            lineColor: [0, 0, 0],
            valign: 'middle',
            textColor: [0, 0, 0]
          },
          columnStyles: {
            0: { cellWidth: 25 },
            1: { cellWidth: 25 },
            2: { cellWidth: 25 },
            3: { cellWidth: 25 },
            4: { cellWidth: 25 },
            5: { cellWidth: 25 }
          }
        });
        finalY = pdf.lastAutoTable.finalY + 10;

        if (finalY > pageHeight - footerHeight - bottomMargin - 40) {
          pdf.addPage();
          finalY = 10;
        }

        // Section-wise Summary calculation for PDF
        const sectionMetadata = {
          "1": { name: "Serial Number verification", base: 44 },
          "2": { name: "Building", base: 8 },
          "3": { name: "Tower", base: 8 },
          "4": { name: "Power Supply", base: 22 },
          "5": { name: "Kavach  Equipment", base: 36 },
          "6": { name: "RF Communication equipment on tower", base: 16 },
          "7": { name: "OFC Networking rack", base: 12 },
          "8": { name: "Relay rack", base: 13 },
          "9": { name: "Earthing", base: 5 },
          "10": { name: "Indoor wiring / cabling", base: 8 },
          "11": { name: "Outdoor cabling", base: 3 },
          "12": { name: "RFID Tags", base: 3 },
          "13": { name: "Components Inspection", base: 1 },
        };


        const subSectionMetadata = {
          "4.1": "4.1 IPS(Integrated Power System)",
          "4.2": "4.2 PDU(Power Distribution Unit)",
          "4.3": "4.3 DC-DC Converter",
          "5.1": "5.1 Kavach Unit",
          "5.2": "5.2 SMOCIP(Station Master's Operation-Cum-Indication Panel)",
          "5.3": "5.3 GPS/GSM Antennas",
          "5.4": "5.4 RIU(Remote Interface Unit)",
          "6.1": "6.1 RTU(Radio Tower Unit)",
          "6.2": "6.2 RF Antenna Installation"
        };

        const sectionStats = {};
        Object.keys(sectionMetadata).forEach(id => {
          const base = sectionMetadata[id].base;
          const sectionRows = observationsArray.filter(obs => obs.S_no && obs.S_no.split('.')[0] === id);

          let customCount = 0;
          sectionRows.forEach(obs => {
            const snoParts = obs.S_no.split('.');
            const lastPart = parseInt(snoParts[snoParts.length - 1]);
            if (id === "1" && lastPart > 44) customCount++;
            if (id === "2" && lastPart > 7) customCount++;
          });

          const total = base + customCount;
          let closed = 0;
          sectionRows.forEach(obs => {
            const status = obs.observation_status ? obs.observation_status.trim() : "";
            const isClosed = ["Available", "Present", "Ok", "Yes", "Routing Done", "Fixed", "Secured", "Installed", "Connected", "Aligned", "Torquing done", "Positioning done", "Configured", "Welding done", "Earthing done", "Matching", "Not Applicable", "Coating done", "Applied", "Cables Connected", "Metal clamps implemented", "Locked", "Verified and ok"].includes(status);
            if (isClosed) closed++;
          });

          sectionStats[id] = {
            name: sectionMetadata[id].name,
            total: total,
            closed: closed
          };
        });

        const hasAnyOpenPoints = Object.keys(sectionStats).some(id => (sectionStats[id].total - sectionStats[id].closed) > 0);

        // Calculate overall stats for filename and status
        let totalClosedOverallNum = 0;
        let totalPointsOverallNum = 0;
        Object.keys(sectionStats).forEach(id => {
          totalClosedOverallNum += sectionStats[id].closed;
          totalPointsOverallNum += sectionStats[id].total;
        });
        const openPointsNum = totalPointsOverallNum - totalClosedOverallNum;
        const completionStatus = (openPointsNum === 0) ? "Completed" : "NotCompleted";
        const fileName = await getVersionedFileName(stationId, formattedInspectionDate, completionStatus);

        if (!fileName) {
          alert("File name is required to save the report.");
          pdfButton.disabled = false;
          pdfButton.textContent = "Convert to PDF";
          return;
        }

        // --- Timings Table ---

        // Time table removed


        // --- Completion Status Table ---
        pdf.autoTable({
          startY: finalY,
          head: [],
          body: [["", "", ""]],
          margin: { right: 10 },
          theme: "grid",
          styles: {
            fontSize: 10,
            cellPadding: 2,
            overflow: 'linebreak',
            lineWidth: 0.1,
            lineColor: [0, 0, 0],
            halign: 'center',
            valign: 'middle'
          },
          columnStyles: {
            0: { cellWidth: 61 },
            1: { cellWidth: 62 },
            2: { cellWidth: 62 }
          },
          bodyStyles: {
            lineWidth: 0.5,
            lineColor: [0, 0, 0],
            valign: 'middle',
            textColor: [0, 0, 0]
          },
          didDrawCell: function (data) {
            if (data.row.section === 'body') {
              const { column, cell } = data;
              if (column.index === 0) {
                pdf.setFont("helvetica", "bold");
                pdf.setFontSize(10);
                pdf.text("Completion Status", cell.x + 5, cell.y + cell.height / 2 + 3);
              }
              const boxSize = 6;
              const imgSize = 5;
              const offsetY = cell.height / 2 - boxSize / 2;
              if (column.index === 1) {
                const boxX = cell.x + 10;
                const boxY = cell.y + offsetY;
                pdf.setLineWidth(0.5);
                pdf.rect(boxX, boxY, boxSize, boxSize);
                if (openPointsNum === 0) {
                  pdf.addImage("tick.png", "PNG", boxX + 0.5, boxY + 0.5, imgSize, imgSize);
                }
                pdf.setFont("helvetica", "normal");
                pdf.setFontSize(10);
                pdf.text("Completed", boxX + boxSize + 6, boxY + boxSize - 1);
              }
              if (column.index === 2) {
                const boxX = cell.x + 10;
                const boxY = cell.y + offsetY;
                pdf.setLineWidth(0.5);
                pdf.rect(boxX, boxY, boxSize, boxSize);
                if (openPointsNum !== 0) {
                  pdf.addImage("cross.png", "PNG", boxX + 0.5, boxY + 0.5, imgSize, imgSize);
                }
                pdf.setFont("helvetica", "normal");
                pdf.setFontSize(10);
                pdf.text("Not Completed", boxX + boxSize + 6, boxY + boxSize - 1);
              }
            }
          }
        });
        finalY = pdf.lastAutoTable.finalY + 10;

        // Summary Table (Total, Closed, Open) - Replaces Section-wise Summary
        pdf.autoTable({
          startY: finalY,
          head: [["Total Points", "Closed Points", "Open Points"]],
          body: [[totalPointsOverallNum, totalClosedOverallNum, openPointsNum]],
          theme: "grid",
          styles: {
            fontSize: 10,
            cellPadding: 1,
            halign: 'center',
            valign: 'middle',
            lineWidth: 0.1,
            lineColor: [0, 0, 0]
          },
          headStyles: {
            fillColor: [0, 108, 204],
            textColor: [255, 255, 255],
            fontStyle: 'bold',
            lineWidth: 0.5,
            lineColor: [0, 0, 0]
          },
          bodyStyles: {
            lineWidth: 0.5,
            lineColor: [0, 0, 0],
            textColor: [0, 0, 0]
          },
          margin: { right: 10 },
          columnStyles: {
            0: { cellWidth: 61 },
            1: { cellWidth: 62 },
            2: { cellWidth: 62 }
          }
        });
        finalY = pdf.lastAutoTable.finalY + 10;







        function calculateRowHeight(row, sectionId) {
          const imagesCount = imageData[row.S_no]?.length || 0;
          const baseHeight = imagesCount > 0 ? Math.max(30, imagesCount * 28) : 10;
          const cellPadding = 2 * 2;
          const lineWidth = 0.1 * 2;
          const textHeight = 10;
          const totalHeight = baseHeight + cellPadding + lineWidth + textHeight;
          console.log(`Row ${row.S_no} height: ${totalHeight}px (base: ${baseHeight}, padding: ${cellPadding}, line: ${lineWidth}, text: ${textHeight})`);
          return totalHeight;
        }

        function getFittingRows(rows, availableHeight, sectionId, forceFirstOne = false) {
          const headHeight = 10 + (2 * 2) + (0.5 * 2);
          let totalHeight = headHeight;
          const fittingRows = [];

          for (let i = 0; i < rows.length; i++) {
            const rowHeight = calculateRowHeight(rows[i], sectionId);
            if (totalHeight + rowHeight <= availableHeight || (forceFirstOne && i === 0 && sectionId === "2")) {
              fittingRows.push(rows[i]);
              totalHeight += rowHeight;
            } else {
              break;
            }
            if (!forceFirstOne && fittingRows.length >= 1) break;
          }
          console.log(`Fitting rows for section ${sectionId}: ${fittingRows.length}, Total height: ${totalHeight}px, Available: ${availableHeight}px, Force: ${forceFirstOne}`);
          return fittingRows;
        }

        const groupedObservations = groupObservationsBySection(pdfObservations);
        console.log('Grouped Observations:', groupedObservations);
        for (let sectionId in groupedObservations) {
          const sectionObservations = groupedObservations[sectionId];
          const parseDate = s => {
            if (!s || typeof s !== 'string') return null;
            const [datePart, timePart] = s.split(" ");
            if (!datePart || !timePart) return null;
            const date = new Date(`${datePart}T${timePart}`);
            return isNaN(date.getTime()) ? null : date;
          };
          let sectionStartTime = "-", sectionCompletedTime = "-", sectionTotalTime = "-";
          let sectionStartObj = null, sectionCompletedObj = null;
          if (sectionId !== "1") {
            const createdTimes = sectionObservations.map(obs => parseDate(obs.created_at)).filter(Boolean);
            const updatedTimes = sectionObservations.map(obs => parseDate(obs.updated_at)).filter(Boolean);
            if (createdTimes.length > 0) {
              sectionStartObj = new Date(Math.min(...createdTimes));
              sectionStartTime = sectionStartObj.toLocaleString();
            }
            if (updatedTimes.length > 0) {
              sectionCompletedObj = new Date(Math.max(...updatedTimes));
              sectionCompletedTime = sectionCompletedObj.toLocaleString();
            } else if (createdTimes.length > 0) {
              sectionCompletedObj = new Date(Math.max(...createdTimes));
              sectionCompletedTime = sectionCompletedObj.toLocaleString();
            }
            if (sectionStartObj && sectionCompletedObj) {
              const ms = sectionCompletedObj - sectionStartObj;
              const totalSeconds = Math.floor(ms / 1000);
              const hours = Math.floor(totalSeconds / 3600);
              const minutes = Math.floor((totalSeconds % 3600) / 60);
              const seconds = totalSeconds % 60;
              sectionTotalTime = `${hours}h ${minutes}m ${seconds}sec`;
            }
          }
          const sectionCaptions = {
            1: "1.0 Serial Number Verification",
            2: "2.0 Building",
            3: "3.0 Tower",
            4: "4.0 Power Supply",
            5: "5.0 Kavach Equipment",
            6: "6.0 RF Communication Equipment On Tower",
            7: "7.0 OFC Networking Rack",
            8: "8.0 Relay Rack",
            9: "9.0 Earthing",
            10: "10.0 Indoor Wiring / Cabling",
            11: "11.0 Outdoor Cabling",
            12: "12.0 RFID Tags",
            13: "13.0 Components Inspection"
          };
          const sectionCaption = sectionCaptions[sectionId] || `Observations for Section ${sectionId}`;
          const sectionHeaderHeight = 8;

          pdf.setFont("helvetica", "bold")
            .setFontSize(12)
            .setTextColor(0, 0, 255)
            .text(sectionCaption, 10, finalY);
          finalY += sectionHeaderHeight;


          // Time table removed as per user request


          // Used pre-loaded imageData from outer scope for efficiency
          const rows = sectionObservations.map(obs => {
            const imagesCount = imageData[obs.S_no]?.length || 0;
            const calculatedHeight = imagesCount > 0 ? Math.max(30, imagesCount * 28) : 0;
            return {
              S_no: obs.S_no,
              Description: formatDescription(obs.observation_text).trim(),
              barcode: obs.barcode_kavach_main_unit,
              Requirement: (obs.requirement_text || "N/A").trim(),
              Status: obs.observation_status,
              Remarks: obs.remarks,
              imageBase64: imageData[obs.S_no][0] || "",
              calculatedHeight
            };
          });
          let availableHeight = pageHeight - finalY - footerHeight - bottomMargin;
          if (availableHeight < sectionHeaderHeight + bottomMargin + 30) {
            pdf.addPage();
            finalY = 10;
            availableHeight = pageHeight - finalY - footerHeight - bottomMargin;
          }
          const showRequirement = sectionId !== "1";



          // Build dynamic body with subsections
          const tableBody = [];
          let lastPdfSubsection = "";

          // Sort rows similarly
          rows.sort((a, b) => {
            const aParts = String(a.S_no).split('.').map(Number);
            const bParts = String(b.S_no).split('.').map(Number);
            for (let i = 0; i < Math.max(aParts.length, bParts.length); i++) {
              const av = aParts[i] || 0;
              const bv = bParts[i] || 0;
              if (av !== bv) return av - bv;
            }
            return 0;
          });

          rows.forEach(r => {
            const parts = String(r.S_no).split('.');
            if (parts.length >= 2) {
              const currentSubsection = parts[0] + "." + parts[1];
              if (currentSubsection !== lastPdfSubsection && subSectionMetadata[currentSubsection]) {
                // Add Title Row
                tableBody.push([{
                  content: subSectionMetadata[currentSubsection],
                  colSpan: showRequirement ? 6 : 5,
                  styles: { fillColor: [230, 242, 255], fontStyle: 'bold', textColor: [0, 86, 179] }
                }]);
                lastPdfSubsection = currentSubsection;
              }
            }

            // Strip HTML and styles from status text
            const cleanStatus = decodeHtmlEntities(String(r.Status || "").replace(/<[^>]*>/g, ""));

            let desc = decodeHtmlEntities(String(r.Description || "").replace(/<\/?b>/g, ""));
            if (r.barcode && r.barcode.trim() !== "") {
              const cleanBarcode = r.barcode.trim();
              desc = desc.split(cleanBarcode).join('').trim();
              while (desc.endsWith('-')) {
                desc = desc.slice(0, -1).trim();
              }
              desc += ` - ${cleanBarcode}`;
            }

            tableBody.push([
              r.S_no,
              desc,
              ...(showRequirement ? [r.Requirement] : []),
              cleanStatus,
              r.Remarks,
              ...(sectionId === "0" ? [] : [{ content: "", raw: r.imageBase64, styles: r.calculatedHeight > 0 ? { minCellHeight: r.calculatedHeight } : {} }])
            ]);
          });

          pdf.autoTable({
            startY: finalY,
            margin: { right: 10 },
            head: [["S.No", "Aspect", ...(showRequirement ? ["Requirement"] : []), "Status", "Observation", ...(sectionId === "0" ? [] : ["Image"])]],
            body: tableBody,
            theme: "grid",
            showHead: 'everyPage',
            rowPageBreak: "avoid",
            styles: {
              fontSize: 10,
              cellPadding: 2,
              overflow: 'linebreak',
              lineWidth: 0.1,
              lineColor: [0, 0, 0],
              halign: 'center',
              valign: 'middle'
            },
            headStyles: {
              textColor: [255, 255, 255],
              fillColor: [0, 102, 204],
              lineWidth: 0.5,
              lineColor: [0, 0, 0]
            },
            bodyStyles: {
              lineWidth: 0.5,
              lineColor: [0, 0, 0],
              valign: 'middle',
              textColor: [0, 0, 0]
            },
            columnStyles: (() => {
              if (sectionId === "1") {
                return {
                  0: { cellWidth: 15, halign: 'center' }, // S.No
                  1: { cellWidth: showRequirement ? 35 : 50, halign: 'left' }, // Description
                  ...(showRequirement ? { 2: { cellWidth: 35, halign: 'left' } } : {}), // Requirement
                  [showRequirement ? 3 : 2]: { cellWidth: 33, halign: 'left' }, // Status
                  [showRequirement ? 4 : 3]: { cellWidth: 38, halign: 'left' }, // Remarks
                  [showRequirement ? 5 : 4]: { cellWidth: 49, halign: 'center' } // Image
                };
              } else {
                // Original column widths for other sections
                return {
                  0: { cellWidth: 15, halign: 'center' }, // S.No
                  1: { cellWidth: showRequirement ? 35 : 55, halign: 'left' }, // Description
                  ...(showRequirement ? { 2: { cellWidth: 41, halign: 'left' } } : {}), // Requirement
                  [showRequirement ? 3 : 2]: { cellWidth: 25, halign: 'left' }, // Status
                  [showRequirement ? 4 : 3]: { cellWidth: 32, halign: 'left' }, // Remarks
                  [showRequirement ? 5 : 4]: { cellWidth: 38, halign: 'center' } // Image
                };
              }
            })()
            ,
            didParseCell: function (data) {
              const statusColIndex = showRequirement ? 3 : 2;
              if (data.row.section === 'body' && data.column.index === statusColIndex) {
                const statusText = String(data.cell.raw).trim();
                const s_no = String(data.row.raw[0]);
                function matchesSno(sno, pattern) {
                  return pattern.split(',').some(part => {
                    if (part.includes('-')) {
                      const [start, end] = part.split('-').map(p => parseFloat(p));
                      const num = parseFloat(sno);
                      return !isNaN(num) && num >= start && num <= end;
                    }
                    return sno === part.trim();
                  });
                }
                let textColor = [0, 0, 0];
                for (const key in specificOptions) {
                  if (matchesSno(s_no, key)) {
                    const values = specificOptions[key];
                    if (values.includes(statusText)) {
                      if (statusText.includes("Not") || statusText.includes("No")) {
                        textColor = [255, 0, 0];
                      } else if (statusText.includes("NA")) {
                        textColor = [128, 128, 128];
                      } else {
                        textColor = [0, 128, 0];
                      }
                    }
                  }
                }
                data.cell.styles.textColor = textColor;
              }
            },
            didDrawCell: function (data) {
              try {
                const imageColIndex = showRequirement ? 5 : 4;
                if (data.row.section === 'body' && data.column.index === imageColIndex) {
                  const row = rows[data.row.index];
                  if (!row || !row.S_no) {
                    console.warn(`No valid row or S_no at index ${data.row.index}`);
                    return;
                  }
                  const S_no = row.S_no;
                  const images = Array.isArray(imageData[S_no]) ? imageData[S_no] : [];
                  if (images.length === 0) {
                    console.log(`No images for S_no: ${S_no}`);
                    return;
                  }
                  const imgX = data.cell.x + 2;
                  let imgY = data.cell.y + 2;
                  const maxWidth = data.cell.width - 4;
                  const maxCellHeight = Math.max(10, data.cell.height - 4);
                  const individualHeight = Math.min(25, maxCellHeight / images.length - 2);
                  for (const base64 of images) {
                    if (typeof base64 === 'string' && base64.startsWith('data:image/jpeg;base64,')) {
                      pdf.addImage(base64, 'JPEG', imgX, imgY, maxWidth, individualHeight);
                      imgY += individualHeight + 2;
                    } else {
                      console.warn(`Invalid base64 image for S_no: ${S_no}`);
                    }
                  }
                }
              } catch (error) {
                console.error("üö® Error in didDrawCell function:", error.message, error.stack);
              }
            },
            didCalculateCellHeight: function (data) {
              const imageColIndex = showRequirement ? 5 : 4;
              if (data.row.section === 'body' && data.column.index === imageColIndex) {
                const images = Array.isArray(imageData[data.row.raw[0]]) ? imageData[data.row.raw[0]] : [];
                if (images.length === 0) return;
                const imageHeight = 25;
                const spacing = 2;
                const padding = 6;
                const totalImageHeight = (imageHeight + spacing) * images.length - spacing;
                const requiredHeight = totalImageHeight + padding;
                if (requiredHeight > data.cell.height) {
                  data.cell.height = requiredHeight;
                }
              }
            }
          });
          finalY = pdf.lastAutoTable.finalY + 10;
          if (finalY > pageHeight - footerHeight - bottomMargin) {
            pdf.addPage();
            finalY = 10;
          }
        }

        // --- Pending Items Detailed Section (Moved to End) ---
        // --- Pending Items Detailed Section (Moved to End) ---
        const closedStatuses = ["Available", "Present", "Ok", "Yes", "Routing Done", "Fixed", "Secured", "Installed", "Connected", "Aligned", "Torquing done", "Positioning done", "Configured", "Welding done", "Earthing done", "Matching", "Not Applicable", "Coating done", "Applied", "Cables Connected", "Metal clamps implemented", "Locked", "Verified and ok"];

        // Create a Set of closed S_nos for efficient lookup
        const closedSet = new Set();
        observationsArray.forEach(obs => {
          const status = obs.observation_status ? obs.observation_status.trim() : "";
          if (status && closedStatuses.includes(status)) {
            closedSet.add(obs.S_no);
          }
        });

        // Collect pending points per section
        const pendingBySection = {};
        Object.keys(sectionMetadata).forEach(id => pendingBySection[id] = new Set());

        // 1. Build a master set of ALL expected S_nos from specificOptions
        const requiredSnos = new Set();
        if (typeof specificOptions !== 'undefined') {
          Object.keys(specificOptions).forEach(keyGroup => {
            // keyGroup is a comma-separated string of S_nos
            keyGroup.split(',').forEach(sno => {
              sno = sno.trim();
              if (sno) requiredSnos.add(sno);
            });
          });
        }

        // 2. Add any S_nos that are actually present in the observations (custom points)
        observationsArray.forEach(obs => {
          if (obs.S_no) requiredSnos.add(obs.S_no);
        });

        // 3. Determine Pending: Required - Closed
        requiredSnos.forEach(sno => {
          if (!closedSet.has(sno)) {
            // Determine section from S_no (assuming format Section.SubPoint)
            const sectionId = sno.split('.')[0];
            if (pendingBySection[sectionId]) {
              pendingBySection[sectionId].add(sno);
            } else {
              // Fallback if sectionId is not standard
              if (!pendingBySection["Other"]) pendingBySection["Other"] = new Set();
              pendingBySection["Other"].add(sno);
            }
          }
        });

        const hasPendingItems = Object.keys(pendingBySection).some(id => pendingBySection[id].size > 0);

        if (hasPendingItems) {
          if (finalY > pageHeight - footerHeight - bottomMargin - 40) {
            pdf.addPage();
            finalY = 10;
          } else {
            finalY += 10;
          }

          pdf.setFontSize(12);
          pdf.setTextColor(0, 0, 255); // Red color
          pdf.setFont("helvetica", "bold");
          pdf.text("The following are the pending items to be verified during the next inspection", 14, finalY);
          finalY += 10;

          const sortedSections = Object.keys(pendingBySection)
            .filter(id => pendingBySection[id].size > 0)
            .sort((a, b) => {
              if (a === 'Other') return 1;
              if (b === 'Other') return -1;
              return Number(a) - Number(b);
            });

          // Use a simple table to list section and points for better alignment and wrapping
          const pendingSummaryData = sortedSections.map(sectionId => {
            const points = Array.from(pendingBySection[sectionId]).sort((a, b) => {
              // Sort points nicely (1.1, 1.2, 1.10 etc)
              const aParts = a.split('.').map(Number);
              const bParts = b.split('.').map(Number);
              for (let i = 0; i < Math.max(aParts.length, bParts.length); i++) {
                const av = aParts[i] || 0;
                const bv = bParts[i] || 0;
                if (av !== bv) return av - bv;
              }
              return 0;
            });
            const sectionName = sectionMetadata[sectionId] ? sectionMetadata[sectionId].name : (sectionId === "Other" ? "Other" : "");
            const title = `Section ${sectionId}: ${sectionName}`;
            const pointsList = points.join(', ');
            return [title, pointsList];
          });

          pdf.autoTable({
            startY: finalY,
            head: [["Section Name", "Pending Points"]],
            body: pendingSummaryData,
            theme: "grid",
            styles: {
              fontSize: 10,
              cellPadding: 3,
              overflow: 'linebreak',
              lineColor: [0, 0, 0], // BLACK border
              lineWidth: 0.5        // border thickness
            },
            headStyles: {
              fillColor: [0, 112, 192],
              textColor: [255, 255, 255],
              lineColor: [0, 0, 0], // ensure header borders are black
              lineWidth: 0.5
            },
            bodyStyles: {
              textColor: [0, 0, 0],
              lineColor: [0, 0, 0], // body borders
              lineWidth: 0.5
            },
            columnStyles: {
              0: { cellWidth: 60, fontStyle: 'bold' },
              1: { cellWidth: 'auto' }
            }
          });

          finalY = pdf.lastAutoTable.finalY + 10;
        }
        const totalPages = pdf.internal.getNumberOfPages();
        pdf.setPage(totalPages);
        const tableEndY = pdf.lastAutoTable.finalY || (pdf.internal.pageSize.height / 2);
        const noteY = tableEndY + 10;
        pdf.setFont("helvetica", "bold").setFontSize(12);
        pdf.text(
          "Note : This QC report is generated by the system and does not need a physical signature.",
          pdf.internal.pageSize.width / 2,
          noteY,
          { align: "center" }
        );
        const totalPagesFinal = pdf.internal.getNumberOfPages();
        for (let i = 1; i <= totalPagesFinal; i++) {
          pdf.setPage(i)
            .setFont("helvetica", "normal")
            .setFontSize(10);
          pdf.text("EG-IC-FT-33 Rev4", 10, pdf.internal.pageSize.height - 10);
          pdf.text(
            `Page ${i} of ${totalPagesFinal}`,
            pdf.internal.pageSize.width - 10,
            pdf.internal.pageSize.height - 10,
            { align: "right" }
          );
        }
        const pdfBlob = pdf.output('blob');
        await uploadPDF(pdfBlob, fileName);
      } finally {
        pdfButton.disabled = false;
        pdfButton.textContent = "Convert to PDF";
        pdfButton.style.opacity = "1";
      }
    }

    async function getVersionedFileName(stationId, updatedDate, completionStatus) {
      try {
        const response = await fetch(`getNextVersion.php?station_id=${stationId}`);
        const data = await response.json();
        if (data.success) {
          const version = data.version;
          return `${stationId}_${updatedDate}_Report_${completionStatus}_Version-${version}.pdf`;
        } else {
          alert('Error fetching version: ' + data.message);
          return null;
        }
      } catch (error) {
        console.error('Error fetching version:', error);
        alert('Error fetching version');
        return null;
      }
    }

    async function getBase64Image(imgUrl) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.src = imgUrl;
        img.onload = function () {
          const canvas = document.createElement("canvas");
          const maxWidth = 100;
          const maxHeight = 100;
          let width = img.width;
          let height = img.height;
          if (width > height) {
            if (width > maxWidth) {
              height *= maxWidth / width;
              width = maxWidth;
            }
          } else {
            if (height > maxHeight) {
              width *= maxHeight / height;
              height = maxHeight;
            }
          }
          const scale = 6;
          canvas.width = width * scale;
          canvas.height = height * scale;
          const ctx = canvas.getContext("2d");
          ctx.scale(scale, scale);
          ctx.drawImage(img, 0, 0, width, height);
          const base64 = canvas.toDataURL("image/jpeg", 1.0);
          resolve(base64);
        };
        img.onerror = function (error) {
          console.error("Error loading image:", imgUrl, error);
          resolve(null);
        };
      });
    }

    async function fetchReports() {
      const username = localStorage.getItem("user_id");
      if (!username) {
        alert("User ID not found. Cannot fetch reports.");
        return;
      }
      try {
        const response = await fetch(`fetchReports.php?user_id=${username}`);
        const text = await response.text();
        console.log("Raw response:", text);
        const data = JSON.parse(text);
        if (data.success) {
          console.log("Reports:", data.reports);
          displayReports(data.reports);
        } else {
          alert("Error: " + data.message);
        }
      } catch (error) {
        console.error("Error fetching reports:", error);
        alert("An error occurred while fetching reports.");
      }
    }

    function displayReports(reports) {
      const reportContainer = document.getElementById("reportList");
      if (!reportContainer) {
        console.error("Element with ID 'reportList' not found!");
        return;
      }
      reportContainer.innerHTML = "";
      if (reports.length === 0) {
        reportContainer.innerHTML = "<p>No reports available.</p>";
        return;
      }
      reports.forEach(report => {
        const reportItem = document.createElement("div");
        reportItem.innerHTML = `
          <p><strong>Uploaded By:</strong> ${report.user_id}</p>
          <p><strong>File:</strong> <a href="/Uploads/reports/${report.file_name}" target="_blank">${report.file_name}</a></p>
          <p><strong>Uploaded On:</strong> ${report.upload_date}</p>
          <hr>
        `;
        reportContainer.appendChild(reportItem);
      });
    }


    document.addEventListener("DOMContentLoaded", fetchReports);
    async function uploadPDF(pdfBlob, fileName) {
      const formData = new FormData();
      let cleanFileName = fileName.trim();
      if (!cleanFileName.toLowerCase().endsWith(".pdf")) {
        cleanFileName += ".pdf";
      }
      formData.append('file', pdfBlob, cleanFileName);
      const userId = localStorage.getItem("user_id");
      if (userId) {
        formData.append('user_id', userId);
      } else {
        alert("User ID is missing. Cannot upload report.");
        return;
      }
      const response = await fetch('uploadReport.php', { method: 'POST', body: formData });
      const data = await response.json();
      if (data.success) {
        alert(data.message);
        const successMessage = document.getElementById("success-message");
        const goToReportBtn = document.getElementById("go-to-report-btn");
        if (successMessage && goToReportBtn) {
          successMessage.style.display = "block";
          goToReportBtn.style.display = "inline-block";
        }
      } else {
        alert("Error uploading report: " + data.message);
      }
    }

    renderObservations();
  </script>
</body>

</html>